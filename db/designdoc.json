{
  "docs": [
    {
      "_id": "_design/accountOffersExercised",
      "validate_doc_update": "function(newDoc, oldDoc, userCtx, secObj) {\n    if (userCtx && userCtx.roles && (userCtx.roles.indexOf('_admin') !== -1 ||\n        userCtx.roles.indexOf('write') !== -1)) {\n        return;\n    } else {\n        throw ({\n            forbidden: 'You do not have write access to this database'\n        });\n    }\n}",
      "language": "javascript",
      "views": {
        "v1": {
          "map": "function(doc) {\n\n  var time    = new Date(doc.close_time_timestamp),\n    unix      = Math.round(time.getTime()),\n    timestamp = [time.getUTCFullYear(), time.getUTCMonth(), time.getUTCDate(),\n      time.getUTCHours(), time.getUTCMinutes(), time.getUTCSeconds()\n    ];\n\n  doc.transactions.forEach(function(tx) {\n\n    if (tx.metaData.TransactionResult !== 'tesSUCCESS') {\n      return;\n    }\n\n    if (tx.TransactionType !== 'Payment' && tx.TransactionType !== 'OfferCreate') {\n      return;\n    }\n\n    tx.metaData.AffectedNodes.forEach(function(affNode) {\n\n      var node = affNode.ModifiedNode || affNode.DeletedNode;\n\n      if (!node || node.LedgerEntryType !== 'Offer') {\n        return;\n      }\n\n      if (!node.PreviousFields || !node.PreviousFields.TakerPays || !node.PreviousFields.TakerGets) {\n        return;\n      }\n  \n      var exchangeRate = node.exchange_rate,\n        counterparty   = node.FinalFields.Account,\n        pay, get;\n\n      if ( typeof node.PreviousFields.TakerPays === \"object\" ) {\n        pay = {\n          currency : node.PreviousFields.TakerPays.currency,\n          issuer   : node.PreviousFields.TakerPays.issuer,\n          value    : node.PreviousFields.TakerPays.value - node.FinalFields.TakerPays.value\n        }\n        \n      } else {\n        exchangeRate = exchangeRate / 1000000.0;        \n        pay = {\n          currency : \"XRP\",\n          issuer   : null,\n          value    : (node.PreviousFields.TakerPays - node.FinalFields.TakerPays) / 1000000.0, // convert from drops\n        }\n      }\n\n      if ( typeof node.PreviousFields.TakerGets === \"object\" ) {\n        get = {\n          currency : node.PreviousFields.TakerGets.currency,\n          issuer   : node.PreviousFields.TakerGets.issuer,\n          value    : node.PreviousFields.TakerGets.value - node.FinalFields.TakerGets.value\n        }\n        \n      } else {\n        exchangeRate = exchangeRate * 1000000.0;\n        get = {\n          currency : \"XRP\",\n          issuer   : null,\n          value    : (node.PreviousFields.TakerGets - node.FinalFields.TakerGets) / 1000000.0\n        }\n      }\n      \n      emit([tx.Account].concat(timestamp), [\n        pay.currency, \n        pay.issuer, \n        pay.value, \n        get.currency,\n        get.issuer,\n        get.value,\n        \"buy\", //account is buying the base (1st) currency\n        exchangeRate,\n        counterparty,\n        unix,\n        tx.hash\n      ]);\n        \n      emit([counterparty].concat(timestamp), [\n        get.currency,\n        get.issuer,\n        get.value,\n        pay.currency, \n        pay.issuer, \n        pay.value, \n        \"sell\",  //account is selling the base (1st) currency\n        (1 / exchangeRate),\n        tx.Account,\n        unix,\n        tx.hash\n      ]); \n         \n    });\n  });\n}",
          "reduce": "_count"
        }
      }
    },
    {
      "_id": "_design/accountsCreated",
      "validate_doc_update": "function(newDoc, oldDoc, userCtx, secObj) {\n    if (userCtx && userCtx.roles && (userCtx.roles.indexOf('_admin') !== -1 ||\n        userCtx.roles.indexOf('write') !== -1)) {\n        return;\n    } else {\n        throw ({\n            forbidden: 'You do not have write access to this database'\n        });\n    }\n}",
      "language": "javascript",
      "views": {
        "v1": {
          "map": "function( doc ) {\n\n  var time = new Date( doc.close_time_timestamp ),\n    timestamp = [ time.getUTCFullYear( ), time.getUTCMonth( ), time.getUTCDate( ),\n      time.getUTCHours( ), time.getUTCMinutes( ), time.getUTCSeconds( )\n    ];\n\n  doc.transactions.forEach( function( tx ) {\n\n    if ( tx.metaData.TransactionResult !== \"tesSUCCESS\" ) {\n      return;\n    }\n\n      tx.metaData.AffectedNodes.forEach( function( affNode ) {\n\n        if ( affNode.CreatedNode && affNode.CreatedNode.LedgerEntryType === \"AccountRoot\" ) {\n\n          emit( timestamp, [affNode.CreatedNode.NewFields.Account, tx.hash] );\n          \n        }\n\n      } );\n  } );\n}",
          "reduce": "_count"
        }
      }
    },
    {
      "_id": "_design/accountTransactions",
      "language": "javascript",
      "validate_doc_update": "function(newDoc, oldDoc, userCtx, secObj) {\n    if (userCtx && userCtx.roles && (userCtx.roles.indexOf('_admin') !== -1 ||\n        userCtx.roles.indexOf('write') !== -1)) {\n        return;\n    } else {\n        throw ({\n            forbidden: 'You do not have write access to this database'\n        });\n    }\n}",
      "views": {
        "v1": {
          "map": "function(doc) {\n\n  var time    = new Date(doc.close_time_timestamp),\n    unix      = Math.round(time.getTime()),\n    timestamp = [\n      time.getUTCFullYear(), \n      time.getUTCMonth(), \n      time.getUTCDate(),\n      time.getUTCHours(), \n      time.getUTCMinutes(), \n      time.getUTCSeconds()\n    ];\n\n  doc.transactions.forEach(function(tx) {\n\n    //only include successful transactions\n    if (tx.metaData.TransactionResult !== 'tesSUCCESS') return;\n\n    //only include payments\n    if (tx.TransactionType !== 'Payment') return;\n    \n    //ignore \"convert\" payments.  \n    if (tx.Account==tx.Destination) return; \n    \n    \n    //if the Account and Destination are the same, the transaction uses path finding\n    //to exchange one currency for another - practically similar to an \"OfferCreate\".\n    //var isConvert  = (tx.TransactionType=='Payment' && tx.Account==tx.Destination) ? true : false;\n    var offers   = [], \n      IOUchanges = [],\n      XRPchanges = [];\n    var type;\n      \n    //loop through the affected nodes to find values sent and received\n    tx.metaData.AffectedNodes.forEach(function(affNode) {\n\n      var node = affNode.CreatedNode || affNode.ModifiedNode || affNode.DeletedNode;\n      var change = null, fee = parseFloat(tx.Fee);\n      \n      //Look for XRP balance changes in AccountRoot nodes\n      if (node.LedgerEntryType === 'AccountRoot') {\n        change = parseAccountRoot(node, tx.Account, fee);\n        \n        if (change) {\n          //ignore changes that do not involve the sender or the receiver.\n          //these are the result of offers exercised for cross currency payments\n          //and would require similar handling to \"convert\" and offer create.\n          if (change.account != tx.Account && change.account != tx.Destination) return;  \n          if (!type) type = \"XRP\";\n          XRPchanges.push(change);\n        }\n        \n      //Look for IOU balance changes in RippleState nodes\n      } else if (node.LedgerEntryType === 'RippleState') {\n        change = parseRippleState(node);\n        \n        if (change) {\n          //ignore the ones that do not involve the payment sender or receiver\n          if (change.high != tx.Account     && change.low != tx.Account &&\n              change.high != tx.Destination && change.low != tx.Destination) {\n              return;              \n              }\n         \n          //invert the amount if the sending account is the low party? \n          //not entirely sure why we are doing this here.\n          if (tx.Account==change.low) change.value = 0 - change.value;\n         \n         \n          if (tx.Account==change.issuer || tx.Destination==change.issuer) {\n            type = \"issuer\";\n            \n            //must be received\n            if (tx.Destination==change.issuer) \n              IOUchanges.push({\n                account      : tx.Destination,\n                currency     : change.currency,\n                issuer       : change.issuer,\n                type         : \"received\",\n                value        : change.value > 0 ? change.value : 0 - change.value,\n                counterparty : tx.Account          \n              });\n            \n            //must be sent\n            else IOUchanges.push({\n              account      : tx.Account,\n              currency     : change.currency,\n              issuer       : change.issuer,\n              type         : 'sent',\n              value        : change.value > 0 ? change.value : 0 - change.value,\n              counterparty : tx.Destination,          \n            });\n            \n                \n          } else { \n            if (type != \"issuer\") type = \"iou\";\n            if (change.value > 0) IOUchanges.push({\n              account      : tx.Account,\n              currency     : change.currency,\n              issuer       : change.issuer,\n              type         : \"sent\",\n              value        : change.value,\n              counterparty : tx.Destination           \n            });\n            \n            else IOUchanges.push({\n              account      : tx.Destination,\n              currency     : change.currency,\n              issuer       : change.issuer,\n              type         : \"received\",\n              value        : 0 - change.value,\n              counterparty : tx.Account,          \n            });\n          }          \n        }\n      }\n    }); \n    \n    //this is a special case where we are sending to an issuer, in the \n    //issuers own currency - in this case there will only be one IOU balance\n    //change, therefore we need to recipricate it.  I'm not sure that\n    //this covers every situation.\n    if (type==\"issuer\" && !XRPchanges.length && IOUchanges.length==1) {\n      var c = IOUchanges[0];\n      IOUchanges.push({\n        account      : c.counterparty,\n        currency     : c.currency,\n        issuer       : c.issuer,\n        type         : c.type==\"sent\" ? \"received\" : \"sent\",\n        value        : c.value,\n        counterparty : c.account,  \n      });\n    }\n    \n    //handle XRP balance changes. We already excluded\n    //any that did not involve the sending or destination\n    //account, so the counterparty will whichever is the\n    //opposite of the account whose balance changed.          \n    XRPchanges.forEach(function(c){\n      c.counterparty = c.account == tx.Account ? tx.Destination : tx.Account;\n      emit([c.account].concat(timestamp), [c.currency, c.issuer, c.type, c.value, c.counterparty, unix, tx.hash]);\n    });\n    \n\n    IOUchanges.forEach(function(c){\n      emit([c.account].concat(timestamp), [c.currency, c.issuer, c.type, c.value, c.counterparty, unix, tx.hash]);\n    });\n      \n    //if (type==\"issuer\") {  \n    //  XRPchanges.forEach(function(c){log(c)});\n    //  IOUchanges.forEach(function(c){log(c)});\n    //  log(tx.hash);\n    //}   \n  });\n  \n  \n  function parseAccountRoot (node, account, fee) {\n    var balChange, value;\n    \n    //if a new account root has been created, this can\n    //only be XRP received, and cannot be the sending account\n    if (node.NewFields) {\n      value = parseFloat(node.NewFields.Balance) / 1000000.0;\n      \n      return {\n        value    : value,\n        currency : 'XRP',\n        issuer   : '',\n        type     : 'received',\n        account  : node.NewFields.Account\n      };\n\n\n    //otherwise we should have a previous entry and a final\n    //entry, and the balance change is the difference between them.\n    //this could be XRP sent or received, and will include the\n    //transaction fee if this is the sending account\n    } else if (node.FinalFields && node.PreviousFields) {\n    \n      //subtract previous from final to get the total balance change  \n      balChange = node.FinalFields.Balance - node.PreviousFields.Balance;\n        \n      //if this is the sending account, remove the fee by adding it \n      //back to the balance change.  \n      if (account==node.FinalFields.Account) balChange += fee;\n      \n      //if we still have a balance change, log it.  If it is negative,\n      //XRP was sent from the account. Otherwise, it was received\n      if (balChange) {\n        value = balChange<0 ? (0 - balChange) : balChange; //invert if negative  \n        \n        return {\n          value    : parseFloat(value) / 1000000.0,\n          currency : 'XRP',\n          issuer   : '',\n          type     : balChange<0 ? 'sent' : 'received', //sent if negative, else received\n          account  : node.FinalFields.Account\n        };\n      }  \n    }\n\n    return null;\n  }  \n  \n  function parseRippleState (node) {\n    \n    var change = {\n        value        : 0,\n        currency     : '',\n        issuer       : '',\n        type         : '',\n      }, \n      trustHigh,\n      trustLow,\n      trustBalFinal,\n      trustBalPrev;\n\n    if (node.NewFields) {\n      trustHigh         = node.NewFields.HighLimit;\n      trustLow          = node.NewFields.LowLimit;\n      trustBalFinal     = parseFloat(node.NewFields.Balance.value);\n      \n    } else {\n      trustHigh         = node.FinalFields.HighLimit;\n      trustLow          = node.FinalFields.LowLimit;\n      trustBalFinal     = parseFloat(node.FinalFields.Balance.value); \n    }\n\n    if (node.PreviousFields && node.PreviousFields.Balance) {\n      trustBalPrev = parseFloat(node.PreviousFields.Balance.value);\n    } else {\n      trustBalPrev = 0;\n    } \n      \n    change.value = parseFloat(trustBalFinal) - parseFloat(trustBalPrev); \n    change.high  = trustHigh.issuer;\n    change.low   = trustLow.issuer;\n    \n    //Set currency\n    change.currency = (node.NewFields || node.FinalFields).Balance.currency;\n\n    // Set issuer\n    // rules:  \n    //    if the balance is negative, the low party is the issuer\n    //    if the balance is 0, and the balance was previously negative, the low party is the issuer\n    //    if the balance is 0, and the balance was previously positive, the high party is the issuer\n    //    if the balance is positive, the high party is the issuer\n    if (trustBalFinal < 0)                         change.issuer = trustLow.issuer;\n    else if (trustBalFinal==0 && trustBalPrev < 0) change.issuer = trustLow.issuer; \n    else                                           change.issuer = trustHigh.issuer;\n    \n    return change;\n  }\n}"
        }
      }
    },
    {
      "_id": "_design/accountTransactionStats",
      "language": "javascript",
      "validate_doc_update": "function(newDoc, oldDoc, userCtx, secObj) {\n    if (userCtx && userCtx.roles && (userCtx.roles.indexOf('_admin') !== -1 ||\n        userCtx.roles.indexOf('write') !== -1)) {\n        return;\n    } else {\n        throw ({\n            forbidden: 'You do not have write access to this database'\n        });\n    }\n}",
      "views": {
        "v1": {
          "map": "function(doc) {\n\n  var time    = new Date(doc.close_time_timestamp),\n    unix      = Math.round(time.getTime()),\n    timestamp = [\n      time.getUTCFullYear(), \n      time.getUTCMonth(), \n      time.getUTCDate(),\n      time.getUTCHours(), \n      time.getUTCMinutes(), \n      time.getUTCSeconds()\n    ];\n\n  doc.transactions.forEach(function(tx) {\n\n    //only include successful transactions\n    if (tx.metaData.TransactionResult !== 'tesSUCCESS') return;\n\n    emit([tx.Account].concat(timestamp), [tx.TransactionType, unix, tx.hash]);\n  });\n}",
          "reduce": "function( keys, values, rereduce ) {\n\n  var stats = {};\n\n  if ( rereduce ) {\n    values.forEach( function(d) {\n      for (var key in d) {\n        if (stats[key]) stats[key] += d[key];\n        else stats[key] = 1;       \n      }\n    });\n    \n  } else {\n  \n    values.forEach( function(tx) {\n      if (stats[tx[0]]) stats[tx[0]]++;\n      else stats[tx[0]] = 1;\n    });\n  }\n  \n \n  return stats;\n}"
        }
      }
    },
    {
      "_id": "_design/accountTrust",
      "language": "javascript",
      "validate_doc_update": "function(newDoc, oldDoc, userCtx, secObj) {\n    if (userCtx && userCtx.roles && (userCtx.roles.indexOf('_admin') !== -1 ||\n        userCtx.roles.indexOf('write') !== -1)) {\n        return;\n    } else {\n        throw ({\n            forbidden: 'You do not have write access to this database'\n        });\n    }\n}",
      "views": {
        "v1": {
          "map": "function( doc ) {\n\n  var time    = new Date(doc.close_time_timestamp),\n    unix      = Math.round(time.getTime()),\n    timestamp = [time.getUTCFullYear(), time.getUTCMonth(), time.getUTCDate(),\n      time.getUTCHours(), time.getUTCMinutes(), time.getUTCSeconds()\n    ];\n\n  doc.transactions.forEach(function(tx) {\n\n    if (tx.metaData.TransactionResult !== 'tesSUCCESS') {\n      return;\n    }\n\n    if (tx.TransactionType !== 'TrustSet') {\n      return;\n    }\n\n    tx.metaData.AffectedNodes.forEach(function(affNode) {\n      \n      var node = affNode.ModifiedNode || affNode.CreatedNode;\n      \n      if (!node || node.LedgerEntryType !== 'RippleState') {\n        return;\n      }\n      \n      var fields   = node.NewFields || node.FinalFields,\n        low        = fields.LowLimit,\n        high       = fields.HighLimit,\n        lowValue   = parseFloat(low.value, 10), \n        highValue  = parseFloat(high.value, 10);\n      \n      if (lowValue && tx.Account==low.issuer) {      \n        emit([high.issuer].concat(timestamp), [low.issuer,  low.currency, lowValue,   unix, tx.hash]);\n        emit([low.issuer].concat(timestamp),  [high.issuer, low.currency, 0-lowValue, unix, tx.hash]);\n      }\n      \n      if (highValue && tx.Account==high.issuer) {        \n        emit([high.issuer].concat(timestamp), [low.issuer,  low.currency, 0-highValue, unix, tx.hash]);\n        emit([low.issuer].concat(timestamp),  [high.issuer, low.currency, highValue,   unix, tx.hash]);\n      }         \n    });\n  });\n}",
          "reduce": "function( keys, values, rereduce ) {\n\n  var stats = [0,0];\n\n  if ( rereduce ) {\n    values.forEach( function(d) {\n      stats[0] += d[0];\n      stats[1] += d[1];\n    });\n    \n  } else {\n  \n    values.forEach( function(line) {\n      if (line[2]>0) stats[0]++;\n      else stats[1]++;\n    });\n  }\n  \n  return stats;\n}"
        }
      }
    },
    {
      "_id": "_design/balanceChangesByAccount",
      "language": "javascript",
      "validate_doc_update": "function(newDoc, oldDoc, userCtx, secObj) {\n    if (userCtx && userCtx.roles && (userCtx.roles.indexOf('_admin') !== -1 ||\n        userCtx.roles.indexOf('write') !== -1)) {\n        return;\n    } else {\n        throw ({\n            forbidden: 'You do not have write access to this database'\n        });\n    }\n}",
      "views": {
        "v1": {
          "map": "function( doc ) {\n\n  var time = new Date( doc.close_time_timestamp ),\n    timestamp = [ time.getUTCFullYear( ), time.getUTCMonth( ), time.getUTCDate( ),\n      time.getUTCHours( ), time.getUTCMinutes( ), time.getUTCSeconds( )\n    ];\n\n  doc.transactions.forEach( function( tx ) {\n\n    if ( tx.metaData.TransactionResult !== \"tesSUCCESS\" )\n      return;\n\n    tx.metaData.AffectedNodes.forEach( function( affNode ) {\n\n      var node = affNode.CreatedNode || affNode.ModifiedNode || affNode.DeletedNode;\n\n      if ( !node || node.LedgerEntryType !== \"RippleState\" ) {\n        return;\n      }\n\n      var currency,\n        highParty,\n        lowParty,\n        prevBal,\n        finalBal,\n        balChange;\n\n      if ( node.NewFields ) {\n\n        // trustline created with non-negative balance\n\n        if ( parseFloat( node.NewFields.Balance.value ) === 0 ) {\n          return;\n        }\n\n        currency = node.NewFields.Balance.currency;\n        highParty = node.NewFields.HighLimit.issuer;\n        lowParty = node.NewFields.LowLimit.issuer;\n\n        prevBal = 0;\n        finalBal = parseFloat( node.NewFields.Balance.value );\n        balChange = finalBal - prevBal;\n\n      } else if ( node.PreviousFields && node.PreviousFields.Balance ) {\n\n        // trustline balance modified\n\n        currency = node.FinalFields.Balance.currency;\n        lowParty = node.FinalFields.LowLimit.issuer;\n        highParty = node.FinalFields.HighLimit.issuer;\n\n        prevBal = parseFloat( node.PreviousFields.Balance.value );\n        finalBal = parseFloat( node.FinalFields.Balance.value );\n        balChange = finalBal - prevBal;\n\n      } else {\n\n        return;\n      }\n\n      emit( [ lowParty, currency ].concat( timestamp ), balChange );\n      emit( [ highParty, currency ].concat( timestamp ), ( 0 - balChange ) );\n\n    } );\n  } );\n}",
          "reduce": "_sum"
        }
      }
    },
    {
      "_id": "_design/currencyBalances",
      "language": "javascript",
      "lists": {
        "balancesByAccount": "function(head, req) {\n  var row, accounts = {}, response = [];\n  while(row = getRow()) {\n    var account = row.value[0];\n    \n    //loop through the balances to find the latest change for each account\n    if (!accounts[account] || row.value[3]>accounts[account][1]) \n      accounts[account] = [row.value[1], row.value[3]];\n  }\n  \n  for (var account in accounts) {\n    if (!accounts[account][0]) continue;  //ignore 0 balances\n\n    response.push([\n      account,\n      accounts[account][0],\n      new Date(accounts[account][1])\n    ]);\n  }\n  \n  send(toJSON(response));\n}\n\n/*\n * \n \n http://127.0.0.1:5984/ripple2/_design/currencyBalances/_list/balancesByAccount/v1?startkey=[\"CNY.rnuF96W4SZoCJmbHYBFoJZpR8eCaxNvekK\",2013]&endkey=[\"CNY.rnuF96W4SZoCJmbHYBFoJZpR8eCaxNvekK\",2015]\n \n http://127.0.0.1:5984/ripple2/_design/currencyBalances/_list/balancesByAccount/v1?startkey=[\"USD.rvYAfWj5gh67oV6fW32ZzP3Aw4Eubs59B\",2013]&endkey=[\"USD.rvYAfWj5gh67oV6fW32ZzP3Aw4Eubs59B\",2015]\n \n http://127.0.0.1:5984/ripple2/_design/currencyBalances/_list/balancesByAccount/v1?startkey=[\"XRP\",2013]&endkey=[\"XRP\",2015]\n \n \n * * \n */"
      },
      "validate_doc_update": "function(newDoc, oldDoc, userCtx, secObj) {\n    if (userCtx && userCtx.roles && (userCtx.roles.indexOf('_admin') !== -1 ||\n        userCtx.roles.indexOf('write') !== -1)) {\n        return;\n    } else {\n        throw ({\n            forbidden: 'You do not have write access to this database'\n        });\n    }\n}",
      "views": {
        "v1": {
          "map": "function (doc) {\n\n  var time    = new Date(doc.close_time_timestamp),\n    unix      = Math.round(time.getTime()),\n    timestamp = [\n      time.getUTCFullYear(), \n      time.getUTCMonth(), \n      time.getUTCDate(),\n      time.getUTCHours(), \n      time.getUTCMinutes(), \n      time.getUTCSeconds()\n    ];\n\n  doc.transactions.forEach( function( tx ) {\n\n    if ( tx.metaData.TransactionResult !== \"tesSUCCESS\" ) {\n      return;\n    }\n\n    tx.metaData.AffectedNodes.forEach( function( affNode ) {\n      var node = affNode.ModifiedNode || affNode.CreatedNode || affNode.DeletedNode;\n    \n      if (!node) return;\n      if (node.LedgerEntryType === \"AccountRoot\" ) {\n      \n        var fields = node.FinalFields || node.NewFields;\n          balance, previous, change;\n          \n        if (fields) {\n          balance  = fields.Balance,\n          previous = node.PreviousFields ? node.PreviousFields.Balance : 0,\n          change   = (balance - previous) / 1000000.0;\n            \n          balance  = balance / 1000000.0; //convert to XRP\n         \n          emit([\"XRP\"].concat(timestamp), [fields.Account, balance, change, unix, tx.hash]);\n        } \n      \n      } else if (node.LedgerEntryType === \"RippleState\") {\n       \n        var balance, previous, change;\n        var currency, issuer, highParty, lowParty, highLimit, lowLimit;\n  \n        if ( node.NewFields ) {\n  \n          // trustline created with non-negative balance\n  \n          if ( parseFloat( node.NewFields.Balance.value ) === 0 ) {\n            return;\n          }\n  \n          currency  = node.NewFields.Balance.currency;\n          highParty = node.NewFields.HighLimit.issuer;\n          highLimit = parseFloat(node.NewFields.HighLimit.value);\n          lowParty  = node.NewFields.LowLimit.issuer;\n          lowLimit  = parseFloat(node.NewFields.LowLimit.value);\n          previous  = 0;\n          balance   = parseFloat(node.NewFields.Balance.value);\n          change    = balance - previous;\n  \n        } else if (node.PreviousFields && node.PreviousFields.Balance) {\n  \n          // trustline balance modified\n  \n          currency  = node.FinalFields.Balance.currency;\n          highParty = node.FinalFields.HighLimit.issuer;\n          highLimit = parseFloat(node.FinalFields.HighLimit.value);\n          lowParty  = node.FinalFields.LowLimit.issuer;\n          lowLimit  = parseFloat(node.FinalFields.LowLimit.value);\n          previous  = parseFloat(node.PreviousFields.Balance.value);\n          balance   = parseFloat(node.FinalFields.Balance.value);\n          change    = balance - previous;\n  \n        } else {\n          return;\n        }\n  \n        emit([currency+\".\"+lowParty].concat(timestamp),  [highParty, balance, change, unix, tx.hash]);\n        emit([currency+\".\"+highParty].concat(timestamp), [lowParty, (0 - balance), ( 0 - change ), unix, tx.hash]);            \n      } \n    });\n  });\n}",
          "reduce": "function( keys, values, rereduce ) {\n\n  var sum = 0;\n\n  if ( rereduce ) {\n    values.forEach( function(d) {\n      sum += d;\n    });\n    \n  } else {\n  \n    values.forEach( function(d) {\n      sum += d[2]; //balance change\n    });\n  }\n  \n  return sum;\n}"
        }
      }
    },
    {
      "_id": "_design/currencyBalancesV2",
      "language": "javascript",
      "validate_doc_update": "function(newDoc, oldDoc, userCtx, secObj) {\n    if (userCtx && userCtx.roles && (userCtx.roles.indexOf('_admin') !== -1 ||\n        userCtx.roles.indexOf('write') !== -1)) {\n        return;\n    } else {\n        throw ({\n            forbidden: 'You do not have write access to this database'\n        });\n    }\n}",
      "views": {
        "v2": {
          "map": "function (doc) {\n\n  var time    = new Date(doc.close_time_timestamp);\n  var unix    = Math.round(time.getTime());\n    timestamp = [\n      time.getUTCFullYear(), \n      time.getUTCMonth(), \n      time.getUTCDate(),\n      time.getUTCHours(), \n      time.getUTCMinutes(), \n      time.getUTCSeconds()\n    ];\n  \n  var hash;\n  var nodes;\n  var i;\n  var j;\n  \n  var node;\n  var fields;\n  var balance;\n  var previous;\n  var change;\n  \n  var currency;\n  var issuer; \n  var highParty; \n  var lowParty; \n  var highLimit; \n  var lowLimit;\n  \n  for(i=0; i<doc.transactions.length; i++) {\n\n    if (doc.transactions[i].metaData.TransactionResult !== \"tesSUCCESS\" ) {\n      continue;\n    }\n    \n    hash  = doc.transactions[i].hash;\n    nodes = doc.transactions[i].metaData.AffectedNodes;\n\n    for(j=0; j<nodes.length; j++) {\n      node = nodes[j].ModifiedNode || nodes[j].CreatedNode || nodes[j].DeletedNode;\n    \n      if (!node) continue;\n      if (node.LedgerEntryType === \"AccountRoot\" ) {\n      \n        fields = node.FinalFields || node.NewFields;\n          \n        if (fields) {\n          balance  = fields.Balance,\n          previous = node.PreviousFields ? node.PreviousFields.Balance : 0,\n          change   = (balance - previous) / 1000000.0;\n          balance  = balance / 1000000.0; //convert to XRP\n         \n          emit([\"XRP\"].concat(timestamp), [fields.Account, balance, change, unix, hash]);\n        } \n      \n      } else if (node.LedgerEntryType === \"RippleState\") {\n       \n        if ( node.NewFields ) {\n  \n          // trustline created with non-negative balance\n          if ( parseFloat( node.NewFields.Balance.value ) === 0 ) {\n            continue;\n          }\n  \n          currency  = node.NewFields.Balance.currency;\n          highParty = node.NewFields.HighLimit.issuer;\n          highLimit = parseFloat(node.NewFields.HighLimit.value);\n          lowParty  = node.NewFields.LowLimit.issuer;\n          lowLimit  = parseFloat(node.NewFields.LowLimit.value);\n          previous  = 0;\n          balance   = parseFloat(node.NewFields.Balance.value);\n          change    = balance - previous;\n  \n        } else if (node.PreviousFields && node.PreviousFields.Balance) {\n  \n          // trustline balance modified\n  \n          currency  = node.FinalFields.Balance.currency;\n          highParty = node.FinalFields.HighLimit.issuer;\n          highLimit = parseFloat(node.FinalFields.HighLimit.value);\n          lowParty  = node.FinalFields.LowLimit.issuer;\n          lowLimit  = parseFloat(node.FinalFields.LowLimit.value);\n          previous  = parseFloat(node.PreviousFields.Balance.value);\n          balance   = parseFloat(node.FinalFields.Balance.value);\n          change    = balance - previous;\n  \n        } else {\n          continue;\n        }\n  \n        emit([currency+\".\"+lowParty].concat(timestamp),  [highParty, balance, change, unix, hash]);\n        emit([currency+\".\"+highParty].concat(timestamp), [lowParty, (0 - balance), ( 0 - change ), unix, hash]);            \n      } \n    }\n  }\n}",
          "reduce": "function( keys, values, rereduce ) {\n\n  var sum = 0;\n  var i;\n  \n  if ( rereduce ) {\n    for (i=0; i<values.length; i++) {\n      sum += values[i];\n    }\n    \n  } else {\n    for (i=0; i<values.length; i++) {\n      sum += values[i][2]; //balance change\n    }\n  }\n  \n  return sum;\n}"
        }
      }
    },
    {
      "_id": "_design/ledgersClosed",
      "language": "javascript",
      "validate_doc_update": "function(newDoc, oldDoc, userCtx, secObj) {\n    if (userCtx && userCtx.roles && (userCtx.roles.indexOf('_admin') !== -1 ||\n        userCtx.roles.indexOf('write') !== -1)) {\n        return;\n    } else {\n        throw ({\n            forbidden: 'You do not have write access to this database'\n        });\n    }\n}",
      "views": {
        "v1": {
          "map": "function (doc) {\n  var time = new Date(doc.close_time_timestamp),\n    timestamp = [time.getUTCFullYear(), time.getUTCMonth(), time.getUTCDate(),\n      time.getUTCHours(), time.getUTCMinutes(), time.getUTCSeconds()\n    ];\n\n  emit( timestamp, 1 );\n}",
          "reduce": "_sum"
        }
      }
    },
    {
      "_id": "_design/offers",
      "language": "javascript",
      "validate_doc_update": "function(newDoc, oldDoc, userCtx, secObj) {\n    if (userCtx && userCtx.roles && (userCtx.roles.indexOf('_admin') !== -1 ||\n        userCtx.roles.indexOf('write') !== -1)) {\n        return;\n    } else {\n        throw ({\n            forbidden: 'You do not have write access to this database'\n        });\n    }\n}",
      "views": {
        "v1": {
          "map": "function( doc ) {\n\n  var time    = new Date( doc.close_time_timestamp ),\n    unix      = Math.round(time.getTime()),\n    timestamp = [ time.getUTCFullYear( ), time.getUTCMonth( ), time.getUTCDate( ),\n      time.getUTCHours( ), time.getUTCMinutes( ), time.getUTCSeconds( )\n    ];\n\n  doc.transactions.forEach( function( tx ) {\n\n    if ( tx.metaData.TransactionResult !== 'tesSUCCESS' ) {\n      return;\n    }\n\n    if ( tx.TransactionType !== 'OfferCreate' && tx.TransactionType !== 'OfferCancel' ) {\n      return;\n    }\n    \n    //emit(timestamp, [tx.TransactionType, tx.Account, tx.hash]);\n\n    tx.metaData.AffectedNodes.forEach( function( affNode ) {\n\n      var node = affNode.CreatedNode || affNode.DeletedNode;\n\n      if ( !node || node.LedgerEntryType !== 'Offer' ) {\n        return;\n      }\n\n      \n      var fields = node.NewFields || node.FinalFields;\n      \n      if (!fields) return;\n\n      var exchangeRate = node.exchange_rate,\n        payCurr,\n        payAmnt,\n        getCurr,\n        getAmnt;\n        \n      if ( typeof fields.TakerGets === \"object\" ) {\n        getCurr = fields.TakerGets.currency+\".\"+fields.TakerGets.issuer;\n        getAmnt = parseFloat(fields.TakerGets.value, 10);\n      } else {\n        getCurr = \"XRP\";\n        getAmnt = fields.TakerGets / 1000000.0;\n        exchangeRate = exchangeRate * 1000000.0;\n      }\n        \n      if ( typeof fields.TakerPays === \"object\" ) {\n        payCurr = fields.TakerPays.currency+\".\"+fields.TakerPays.issuer;\n        payAmnt = parseFloat(fields.TakerPays.value, 10);\n      } else {\n        payCurr = \"XRP\";\n        payAmnt = fields.TakerPays / 1000000.0;\n        exchangeRate = exchangeRate / 1000000.0;\n      }\n      \n      emit( [ payCurr+\":\"+getCurr ].concat( timestamp ), [ tx.TransactionType, tx.Account, payAmnt, getAmnt, exchangeRate,     unix, tx.hash] );\n      emit( [ getCurr+\":\"+payCurr ].concat( timestamp ), [ tx.TransactionType, tx.Account, getAmnt, payAmnt, 1 / exchangeRate, unix, tx.hash] );\n\n    } );\n  } );\n}",
          "reduce": "function( keys, values, rereduce ) {\n\n  var stats = [0,0];\n\n  if ( rereduce ) {\n    values.forEach( function(d) {\n      stats[0] += d[0];\n      stats[1] += d[1];\n    });\n    \n  } else {\n  \n    values.forEach( function(tx) {\n      if      (tx[0]=='OfferCreate') stats[0]++;\n      else if (tx[0]=='OfferCancel') stats[1]++;\n    });\n  }\n  \n \n  return stats;\n}"
        }
      }
    },
    {
      "_id": "_design/offersExercisedV3",
      "language": "javascript",
      "validate_doc_update": "function(newDoc, oldDoc, userCtx, secObj) {\n    if (userCtx && userCtx.roles && (userCtx.roles.indexOf('_admin') !== -1 ||\n        userCtx.roles.indexOf('write') !== -1)) {\n        return;\n    } else {\n        throw ({\n            forbidden: 'You do not have write access to this database'\n        });\n    }\n}",
      "views": {
        "v2": {
          "map": "function(doc) {\n  var time      = new Date(doc.close_time_timestamp);\n  var unix      = Math.round(time.getTime());\n  var timestamp = [ time.getUTCFullYear(), time.getUTCMonth(), time.getUTCDate(),\n    time.getUTCHours(), time.getUTCMinutes(), time.getUTCSeconds()\n  ];\n  \n  var account;\n  var hash;\n  var nodes;\n  var node;\n  var i;\n  var j;\n\n  var exchangeRate;\n  var counterparty;\n  var payCurr;\n  var payAmnt;\n  var getCurr;\n  var getAmnt;\n\n  for(i=0; i<doc.transactions.length; i++) {\n\n    if (doc.transactions[i].metaData.TransactionResult !== 'tesSUCCESS') {\n      continue;\n    }\n\n    if (doc.transactions[i].TransactionType !== 'Payment' && \n        doc.transactions[i].TransactionType !== 'OfferCreate') {\n      continue;\n    }\n\n    hash    = doc.transactions[i].hash;\n    account = doc.transactions[i].Account;\n    nodes   = doc.transactions[i].metaData.AffectedNodes;\n    \n    for(j=0; j<nodes.length; j++) {\n    \n      \n      node = nodes[j].ModifiedNode || nodes[j].DeletedNode;\n\n      if (!node || node.LedgerEntryType !== 'Offer') {\n        continue;\n      }\n\n      if (!node.PreviousFields || !node.PreviousFields.TakerPays || !node.PreviousFields.TakerGets) {\n        continue;\n      }\n  \n      exchangeRate = node.exchange_rate;\n      counterparty = node.FinalFields.Account;\n\n      if ( typeof node.PreviousFields.TakerPays === \"object\" ) {\n        payCurr = node.PreviousFields.TakerPays.currency+\".\"+node.PreviousFields.TakerPays.issuer;\n        payAmnt = node.PreviousFields.TakerPays.value - node.FinalFields.TakerPays.value;\n        \n      } else {\n        payCurr = \"XRP\";\n        payAmnt = (node.PreviousFields.TakerPays - node.FinalFields.TakerPays) / 1000000.0; // convert from drops\n        exchangeRate = exchangeRate / 1000000.0;\n      }\n\n      if ( typeof node.PreviousFields.TakerGets === \"object\" ) {\n        getCurr = node.PreviousFields.TakerGets.currency+\".\"+node.PreviousFields.TakerGets.issuer;\n        getAmnt = node.PreviousFields.TakerGets.value - node.FinalFields.TakerGets.value;\n      } else {\n        getCurr = \"XRP\";\n        getAmnt = (node.PreviousFields.TakerGets - node.FinalFields.TakerGets) / 1000000.0;\n        exchangeRate = exchangeRate * 1000000.0;\n      }\n      \n      if (payCurr < getCurr) {\n        emit([payCurr+\":\"+getCurr].concat(timestamp), [payAmnt, getAmnt, exchangeRate, counterparty, account, unix, hash]);\n      } else {\n        emit([getCurr+\":\"+payCurr].concat(timestamp), [getAmnt, payAmnt, 1 / exchangeRate, account, counterparty, unix, hash]);\n      } \n    }\n  }\n}",
          "reduce": "function( keys, values, rereduce ) {\n\n  var stats;\n  var segment;\n  var i;\n  \n  if ( !rereduce ) {\n\n    var time  = values[0][5]; //unix timestamp\n    var price = values[0][2]; //exchange rate\n\n    // initial values\n    stats = {\n      openTime  : time,\n      closeTime : time,\n\n      open  : price,\n      close : price,\n      high  : price,\n      low   : price,\n\n      curr1Volume : 0,\n      curr2Volume : 0,\n      numTrades   : 0\n    };\n\n    for (i=0; i<values.length; i++) {\n      \n      time  = values[i][5]; //unix timestamp\n      price = values[i][2]; //exchange rate\n\n      if (time < stats.openTime) {\n        stats.openTime = time;\n        stats.open     = price;\n      }\n\n      if (stats.closeTime < time) {\n        stats.closeTime = time;\n        stats.close     = price;\n      }\n\n      if (price > stats.high) stats.high = price;\n      if (price < stats.low)  stats.low  = price;\n      \n      stats.curr1Volume += values[i][0];\n      stats.curr2Volume += values[i][1];\n      stats.numTrades++;\n    }\n\n    return stats;\n\n  } else {\n    \n    stats = values[0];\n\n    //skip the first\n    for (i=1; i<values.length; i++) {\n      segment = values[i];\n      \n      if (segment.openTime < stats.openTime) {\n        stats.openTime = segment.openTime;\n        stats.open     = segment.open;\n      }\n      \n      if (stats.closeTime < segment.closeTime) {\n        stats.closeTime = segment.closeTime;\n        stats.close     = segment.close;\n      }\n\n      if (segment.high > stats.high) stats.high = segment.high;\n      if (segment.low < stats.low)   stats.low  = segment.low;\n\n      stats.curr1Volume += segment.curr1Volume;\n      stats.curr2Volume += segment.curr2Volume;\n      stats.numTrades   += segment.numTrades;\n    } \n\n    return stats;\n  }\n}"
        }
      }
    },
    {
      "_id": "_design/transactionStats",
      "language": "javascript",
      "validate_doc_update": "function(newDoc, oldDoc, userCtx, secObj) {\n    if (userCtx && userCtx.roles && (userCtx.roles.indexOf('_admin') !== -1 ||\n        userCtx.roles.indexOf('write') !== -1)) {\n        return;\n    } else {\n        throw ({\n            forbidden: 'You do not have write access to this database'\n        });\n    }\n}",
      "views": {
        "v1": {
          "map": "function(doc) {\n\n  var time    = new Date(doc.close_time_timestamp),\n    unix      = Math.round(time.getTime()),\n    timestamp = [\n      time.getUTCFullYear(), \n      time.getUTCMonth(), \n      time.getUTCDate(),\n      time.getUTCHours(), \n      time.getUTCMinutes(), \n      time.getUTCSeconds()\n    ];\n\n  doc.transactions.forEach(function(tx) {\n\n    //only include successful transactions\n    if (tx.metaData.TransactionResult !== 'tesSUCCESS') return;\n\n    emit(timestamp, [tx.TransactionType, tx.Account, unix, tx.hash]);\n  });\n}",
          "reduce": "function( keys, values, rereduce ) {\n\n  var stats = {};\n\n  if ( rereduce ) {\n    values.forEach( function(d) {\n      for (var key in d) {\n        if (stats[key]) stats[key] += d[key];\n        else stats[key] = d[key];       \n      }\n    });\n    \n  } else {\n  \n    values.forEach( function(tx) {\n      if (stats[tx[0]]) stats[tx[0]]++;\n      else stats[tx[0]] = 1;\n    });\n  }\n  \n \n  return stats;\n}"
        }
      }
    },
    {
      "_id": "_design/valueSentV2",
      "language": "javascript",
      "validate_doc_update": "function(newDoc, oldDoc, userCtx, secObj) {\n    if (userCtx && userCtx.roles && (userCtx.roles.indexOf('_admin') !== -1 ||\n        userCtx.roles.indexOf('write') !== -1)) {\n        return;\n    } else {\n        throw ({\n            forbidden: 'You do not have write access to this database'\n        });\n    }\n}",
      "views": {
        "v1": {
          "map": "// function map (doc) {\nfunction(doc) {\n\n  var time = new Date(doc.close_time_timestamp);\n  var timestamp = [\n    time.getUTCFullYear(), \n    time.getUTCMonth(), \n    time.getUTCDate(),\n    time.getUTCHours(), \n    time.getUTCMinutes(), \n    time.getUTCSeconds()\n  ];\n\n  doc.transactions.forEach(function(tx){\n\n    if (tx.metaData.TransactionResult !== 'tesSUCCESS') {\n      return;\n    }\n\n    if (tx.TransactionType !== 'Payment' && tx.TransactionType !== 'OfferCreate') {\n      return;\n    }\n\n    var changes = parseBalanceChanges(tx);\n    \n    if (changes.length > 0) {\n      changes.forEach(function(change){\n        emit([change.currency, change.issuer].concat(timestamp), [0 - parseFloat(change.value), tx.Account, tx.Destination || null, tx.hash]);\n        //log(change);\n      });\n      \n      //log(tx.hash);\n    }\n    \n  });\n\n  function parseBalanceChanges (tx) {\n\n    var accountBalanceChanges = [];\n    var account     = tx.Account;\n    var destination = tx.Destination || null;\n    \n    tx.metaData.AffectedNodes.forEach(function(affNode){\n\n      var node = affNode.CreatedNode || affNode.ModifiedNode || affNode.DeletedNode;\n\n      // Look for XRP balance change in AccountRoot node\n      if (node.LedgerEntryType === 'AccountRoot') {\n\n        var xrpBalChange = parseAccountRootBalanceChange(node, account);\n        \n        if (xrpBalChange) {\n          xrpBalChange.value += parseFloat(tx.Fee); //remove the fee from the balance change\n          \n          //if we are still negative, XRP was sent.\n          //often this would be zero, indicating only a fee\n          //and not really sending XRP\n          if (xrpBalChange.value<0) {\n            xrpBalChange.value = dropsToXrp(xrpBalChange.value); //convert to XRP\n            accountBalanceChanges.push(xrpBalChange);\n          }\n        }\n      }\n\n      // Look for trustline balance change in RippleState node\n      if (node.LedgerEntryType === 'RippleState') {\n\n        var currBalChange = parseTrustlineBalanceChange(node, account, destination);\n        if (currBalChange) {\n          accountBalanceChanges.push(currBalChange);\n        }\n\n      }\n\n    });\n\n    return accountBalanceChanges;\n  }\n\n\n  function parseAccountRootBalanceChange (node, account) {\n\n/*\n    if (node.NewFields) {\n\n      if (node.NewFields.Account === account) {\n        return {\n          value: dropsToXrp(node.NewFields.Balance),\n          currency: 'XRP',\n          issuer: ''\n        };\n      }\n\n    } else if (node.FinalFields) {\n*/\n      \n    if (node.FinalFields && node.FinalFields.Account === account) {\n\n      var finalBal = node.FinalFields.Balance,\n        prevBal    = node.PreviousFields.Balance,\n        balChange  = finalBal - prevBal;\n      \n      //if the final balance is greater than the previous, xrp was sent\n      if (balChange<0) return {\n        value    : balChange,\n        currency : 'XRP',\n        issuer   : ''\n      };\n    }\n\n\n    return null;\n  }\n\n  function parseTrustlineBalanceChange (node, account, destination) {\n\n    var balChange = {\n        value    : 0,\n        currency : '',\n        issuer   : ''\n      }, \n      trustHigh,\n      trustLow,\n      trustBalFinal,\n      trustBalPrev;\n\n    if (node.NewFields) {\n      trustHigh     = node.NewFields.HighLimit;\n      trustLow      = node.NewFields.LowLimit;\n      trustBalFinal = parseFloat(node.NewFields.Balance.value);\n    } else {\n      trustHigh     = node.FinalFields.HighLimit;\n      trustLow      = node.FinalFields.LowLimit;\n      trustBalFinal = parseFloat(node.FinalFields.Balance.value); \n    }\n\n    if (node.PreviousFields && node.PreviousFields.Balance) {\n      trustBalPrev = parseFloat(node.PreviousFields.Balance.value);\n    } else {\n      trustBalPrev = 0;\n    }\n\n    //ignore any balance changes that do not affect the sending account\n    if (account != trustHigh.issuer && account != trustLow.issuer) {\n      return null;  \n    }\n    \n    // Set currency\n    balChange.currency = (node.NewFields || node.FinalFields).Balance.currency;\n\n    // Set issuer\n    // rules:  \n    //    if the balance is negative, the low party is the issuer\n    //    if the balance is 0, and the balance was previously negative, the low party is the issuer\n    //    if the balance is 0, and the balance was previously positive, the high party is the issuer\n    //    if the balance is positive, the high party is the issuer\n    if (trustBalFinal < 0)                         balChange.issuer = trustLow.issuer;\n    else if (trustBalFinal==0 && trustBalPrev < 0) balChange.issuer = trustLow.issuer; \n    else                                           balChange.issuer = trustHigh.issuer;\n    \n    balChange.value = parseFloat(trustBalFinal) - parseFloat(trustBalPrev);  \n\n    //if the issuer is sending, invert it because its always positive\n    if (balChange.issuer==account) \n      balChange.value = 0 - balChange.value; \n    \n    //if its being sent to the issuer and the issuer\n    //is the low party, invert it \n    if (balChange.issuer==destination && trustLow.issuer==balChange.issuer)\n      balChange.value = 0 - balChange.value;\n\n    //because we are including \"OfferCreate\", the account's balance\n    //could have increased.  therefore, we only want to include \n    //negative balance changes - i.e. balances where money left the\n    //sender/initiator's account\n    if (balChange.value > 0) return null;\n    \n    return balChange;\n  }\n\n  function dropsToXrp (drops) {\n    return parseFloat(drops) / 1000000.0;\n  }\n\n  function xrpToDrops (xrp) {\n    return parseFloat(xrp) * 1000000.0;\n  }\n\n}\n\n// function emit(key, value) {\n//   console.log('key: ' + JSON.stringify(key) + ' value: ' + value);\n// }\n\n// map({\n//       \"accepted\": true,\n//       \"account_hash\": \"ADDDCDB0C57D4F6010713C8A97C09A39EBD9CFF339DD2020B081E87DF3D1FAE0\",\n//       \"close_time\": 444459220,\n//       \"close_time_human\": \"2014-Jan-31 04:53:40\",\n//       \"close_time_resolution\": 10,\n//       \"closed\": true,\n//       \"hash\": \"E02BBDE4A5BB721C72BBF4C2139A0A22637E43A46DEC44B4BF85B8A20F765970\",\n//       \"ledger_hash\": \"E02BBDE4A5BB721C72BBF4C2139A0A22637E43A46DEC44B4BF85B8A20F765970\",\n//       \"ledger_index\": \"4718685\",\n//       \"parent_hash\": \"B3BA5147905C6017354B408D1EF0C9AD0EB3E352BFAB8521B6D392E44E7F1B3D\",\n//       \"seqNum\": \"4718685\",\n//       \"totalCoins\": \"99999998050649525\",\n//       \"total_coins\": \"99999998050649525\",\n//       \"transaction_hash\": \"E7422BEA4FE1789B3EFFEB2293436C371F69F08904EAC7C17C29D64A643A9B29\",\n//       \"transactions\": [\n//         {\n//           \"Account\": \"rU2DL7DwxxEjkRFV6uuSZtmJiosV5YgetS\",\n//           \"Amount\": {\n//             \"currency\": \"BTC\",\n//             \"issuer\": \"rLpq5RcRzA8FU1yUqEPW4xfsdwon7casuM\",\n//             \"value\": \"0.0001\"\n//           },\n//           \"Destination\": \"rLpq5RcRzA8FU1yUqEPW4xfsdwon7casuM\",\n//           \"Fee\": \"15\",\n//           \"Flags\": 0,\n//           \"Paths\": [\n//             [\n//               {\n//                 \"account\": \"rfYv1TXnwgDDK4WQNbFALykYuEBnrR4pDX\",\n//                 \"type\": 1,\n//                 \"type_hex\": \"0000000000000001\"\n//               },\n//               {\n//                 \"account\": \"rsZJQzsexY63t8LdkKhFdkqc29Bh2946Uh\",\n//                 \"type\": 1,\n//                 \"type_hex\": \"0000000000000001\"\n//               },\n//               {\n//                 \"account\": \"rvYAfWj5gh67oV6fW32ZzP3Aw4Eubs59B\",\n//                 \"type\": 1,\n//                 \"type_hex\": \"0000000000000001\"\n//               }\n//             ],\n//             [\n//               {\n//                 \"account\": \"rfYv1TXnwgDDK4WQNbFALykYuEBnrR4pDX\",\n//                 \"type\": 1,\n//                 \"type_hex\": \"0000000000000001\"\n//               },\n//               {\n//                 \"account\": \"r9LqFsCMME6NNSFkb5wmPYaUaf1AzgbKyc\",\n//                 \"type\": 1,\n//                 \"type_hex\": \"0000000000000001\"\n//               },\n//               {\n//                 \"account\": \"rvYAfWj5gh67oV6fW32ZzP3Aw4Eubs59B\",\n//                 \"type\": 1,\n//                 \"type_hex\": \"0000000000000001\"\n//               }\n//             ],\n//             [\n//               {\n//                 \"account\": \"rfYv1TXnwgDDK4WQNbFALykYuEBnrR4pDX\",\n//                 \"type\": 1,\n//                 \"type_hex\": \"0000000000000001\"\n//               },\n//               {\n//                 \"account\": \"rGe5oH9mzzJ5CsfUJhHhraUCrkfY7zEQVV\",\n//                 \"type\": 1,\n//                 \"type_hex\": \"0000000000000001\"\n//               },\n//               {\n//                 \"account\": \"rvYAfWj5gh67oV6fW32ZzP3Aw4Eubs59B\",\n//                 \"type\": 1,\n//                 \"type_hex\": \"0000000000000001\"\n//               }\n//             ],\n//             [\n//               {\n//                 \"account\": \"rfYv1TXnwgDDK4WQNbFALykYuEBnrR4pDX\",\n//                 \"type\": 1,\n//                 \"type_hex\": \"0000000000000001\"\n//               },\n//               {\n//                 \"account\": \"rnziParaNb8nsU4aruQdwYE3j5jUcqjzFm\",\n//                 \"type\": 1,\n//                 \"type_hex\": \"0000000000000001\"\n//               },\n//               {\n//                 \"account\": \"rvYAfWj5gh67oV6fW32ZzP3Aw4Eubs59B\",\n//                 \"type\": 1,\n//                 \"type_hex\": \"0000000000000001\"\n//               }\n//             ]\n//           ],\n//           \"SendMax\": {\n//             \"currency\": \"BTC\",\n//             \"issuer\": \"rU2DL7DwxxEjkRFV6uuSZtmJiosV5YgetS\",\n//             \"value\": \"0.000101353803\"\n//           },\n//           \"Sequence\": 22,\n//           \"SigningPubKey\": \"03B5115CC780BA2EE3F0CA617BA8CC2408BB52A646A0585C236F1BA362F4F8EB89\",\n//           \"TransactionType\": \"Payment\",\n//           \"TxnSignature\": \"304402202D80325969238916D0D873D42684B62DFE8E22264413FC38F26F3512758F8AC202205D5482A0E9E5818250472BE80974083A8C9B093738EB20F3F17AAC7A45942AB8\",\n//           \"hash\": \"0D137EAAD7CC6296B4B330314846E89D484B2C4890936D3FE1969897A31F6D5C\",\n//           \"metaData\": {\n//             \"AffectedNodes\": [\n//               {\n//                 \"ModifiedNode\": {\n//                   \"FinalFields\": {\n//                     \"Balance\": {\n//                       \"currency\": \"BTC\",\n//                       \"issuer\": \"rrrrrrrrrrrrrrrrrrrrBZbvji\",\n//                       \"value\": \"-0.000894562910134798\"\n//                     },\n//                     \"Flags\": 131072,\n//                     \"HighLimit\": {\n//                       \"currency\": \"BTC\",\n//                       \"issuer\": \"rsZJQzsexY63t8LdkKhFdkqc29Bh2946Uh\",\n//                       \"value\": \"0.1\"\n//                     },\n//                     \"HighNode\": \"0000000000000000\",\n//                     \"LowLimit\": {\n//                       \"currency\": \"BTC\",\n//                       \"issuer\": \"rvYAfWj5gh67oV6fW32ZzP3Aw4Eubs59B\",\n//                       \"value\": \"0\"\n//                     },\n//                     \"LowNode\": \"0000000000000113\"\n//                   },\n//                   \"LedgerEntryType\": \"RippleState\",\n//                   \"LedgerIndex\": \"235866687C354C777919CF68490F86E81CCF96E9F068765B964808DE7B97AEAF\",\n//                   \"PreviousFields\": {\n//                     \"Balance\": {\n//                       \"currency\": \"BTC\",\n//                       \"issuer\": \"rrrrrrrrrrrrrrrrrrrrBZbvji\",\n//                       \"value\": \"-0.000994762910134798\"\n//                     }\n//                   },\n//                   \"PreviousTxnID\": \"1CCCFFCB3EBEBDB2F075186858927D4315CB2A93FB601E66FE70ECB07FE5902F\",\n//                   \"PreviousTxnLgrSeq\": 4699097\n//                 }\n//               },\n//               {\n//                 \"ModifiedNode\": {\n//                   \"FinalFields\": {\n//                     \"Balance\": {\n//                       \"currency\": \"BTC\",\n//                       \"issuer\": \"rrrrrrrrrrrrrrrrrrrrBZbvji\",\n//                       \"value\": \"0.001141447515872594\"\n//                     },\n//                     \"Flags\": 65536,\n//                     \"HighLimit\": {\n//                       \"currency\": \"BTC\",\n//                       \"issuer\": \"rfYv1TXnwgDDK4WQNbFALykYuEBnrR4pDX\",\n//                       \"value\": \"0\"\n//                     },\n//                     \"HighNode\": \"0000000000000033\",\n//                     \"LowLimit\": {\n//                       \"currency\": \"BTC\",\n//                       \"issuer\": \"rsZJQzsexY63t8LdkKhFdkqc29Bh2946Uh\",\n//                       \"value\": \"0.1\"\n//                     },\n//                     \"LowNode\": \"0000000000000000\"\n//                   },\n//                   \"LedgerEntryType\": \"RippleState\",\n//                   \"LedgerIndex\": \"2FAC03FAF21C97882149BC3D968431F947547E202841E703786E1B1229D904F0\",\n//                   \"PreviousFields\": {\n//                     \"Balance\": {\n//                       \"currency\": \"BTC\",\n//                       \"issuer\": \"rrrrrrrrrrrrrrrrrrrrBZbvji\",\n//                       \"value\": \"0.001041247515872594\"\n//                     }\n//                   },\n//                   \"PreviousTxnID\": \"1CCCFFCB3EBEBDB2F075186858927D4315CB2A93FB601E66FE70ECB07FE5902F\",\n//                   \"PreviousTxnLgrSeq\": 4699097\n//                 }\n//               },\n//               {\n//                 \"ModifiedNode\": {\n//                   \"FinalFields\": {\n//                     \"Account\": \"rU2DL7DwxxEjkRFV6uuSZtmJiosV5YgetS\",\n//                     \"Balance\": \"172113760760\",\n//                     \"Flags\": 0,\n//                     \"OwnerCount\": 2,\n//                     \"Sequence\": 23\n//                   },\n//                   \"LedgerEntryType\": \"AccountRoot\",\n//                   \"LedgerIndex\": \"C32FC61866A3744D802E52F6276A4680F82738EB4A9671AD2BFFBDA934E068BE\",\n//                   \"PreviousFields\": {\n//                     \"Balance\": \"172113760775\",\n//                     \"Sequence\": 22\n//                   },\n//                   \"PreviousTxnID\": \"18BDA2A877475840B427F8552E946367E0FBA5CC918E065B5CBFE4ED54752DDF\",\n//                   \"PreviousTxnLgrSeq\": 4707221\n//                 }\n//               },\n//               {\n//                 \"ModifiedNode\": {\n//                   \"FinalFields\": {\n//                     \"Balance\": {\n//                       \"currency\": \"BTC\",\n//                       \"issuer\": \"rrrrrrrrrrrrrrrrrrrrBZbvji\",\n//                       \"value\": \"-0.5489575198674392\"\n//                     },\n//                     \"Flags\": 2228224,\n//                     \"HighLimit\": {\n//                       \"currency\": \"BTC\",\n//                       \"issuer\": \"rU2DL7DwxxEjkRFV6uuSZtmJiosV5YgetS\",\n//                       \"value\": \"100\"\n//                     },\n//                     \"HighNode\": \"0000000000000000\",\n//                     \"LowLimit\": {\n//                       \"currency\": \"BTC\",\n//                       \"issuer\": \"rfYv1TXnwgDDK4WQNbFALykYuEBnrR4pDX\",\n//                       \"value\": \"0\"\n//                     },\n//                     \"LowNode\": \"000000000000003B\"\n//                   },\n//                   \"LedgerEntryType\": \"RippleState\",\n//                   \"LedgerIndex\": \"D505A48DABB927A1F2A0E0A4A4393320772BDB14F243FBB38B1F89340E7B5D2E\",\n//                   \"PreviousFields\": {\n//                     \"Balance\": {\n//                       \"currency\": \"BTC\",\n//                       \"issuer\": \"rrrrrrrrrrrrrrrrrrrrBZbvji\",\n//                       \"value\": \"-0.5490578701674392\"\n//                     }\n//                   },\n//                   \"PreviousTxnID\": \"1F99E7E9BCFD285793D54F7CB3161745D7C9B615D68EEFA37E3D77044FF6CA2E\",\n//                   \"PreviousTxnLgrSeq\": 4689485\n//                 }\n//               },\n//               {\n//                 \"ModifiedNode\": {\n//                   \"FinalFields\": {\n//                     \"Balance\": {\n//                       \"currency\": \"BTC\",\n//                       \"issuer\": \"rrrrrrrrrrrrrrrrrrrrBZbvji\",\n//                       \"value\": \"-0.00112098\"\n//                     },\n//                     \"Flags\": 131072,\n//                     \"HighLimit\": {\n//                       \"currency\": \"BTC\",\n//                       \"issuer\": \"rLpq5RcRzA8FU1yUqEPW4xfsdwon7casuM\",\n//                       \"value\": \"1\"\n//                     },\n//                     \"HighNode\": \"0000000000000000\",\n//                     \"LowLimit\": {\n//                       \"currency\": \"BTC\",\n//                       \"issuer\": \"rvYAfWj5gh67oV6fW32ZzP3Aw4Eubs59B\",\n//                       \"value\": \"0\"\n//                     },\n//                     \"LowNode\": \"00000000000000BB\"\n//                   },\n//                   \"LedgerEntryType\": \"RippleState\",\n//                   \"LedgerIndex\": \"DB50D38DF8AA6F652D7BF58229745D8095FFFA9465130D1C1976AAEBB5C2DCDE\",\n//                   \"PreviousFields\": {\n//                     \"Balance\": {\n//                       \"currency\": \"BTC\",\n//                       \"issuer\": \"rrrrrrrrrrrrrrrrrrrrBZbvji\",\n//                       \"value\": \"-0.00102098\"\n//                     }\n//                   },\n//                   \"PreviousTxnID\": \"72E2970A1CE0CB56A8F11F9E36847E59BA62BEDB7DAD6C0461E36C1E694DFEDC\",\n//                   \"PreviousTxnLgrSeq\": 4699069\n//                 }\n//               }\n//             ],\n//             \"TransactionIndex\": 0,\n//             \"TransactionResult\": \"tesSUCCESS\"\n//           }\n//         },\n//         {\n//           \"Account\": \"rs1KQkwBYW1pY7jGeRiNgBkbD6WkPG4cYE\",\n//           \"Amount\": \"4000000\",\n//           \"Destination\": \"rpyUV8W6XRvss6SBkAS8PyzGwMsSDxgNXW\",\n//           \"DestinationTag\": 2,\n//           \"Fee\": \"12\",\n//           \"Flags\": 0,\n//           \"Sequence\": 9113,\n//           \"SigningPubKey\": \"03441A4ED5967DEB25C52892BA8274EF6E1D7293609C0C4CF7DFF5257230365DDB\",\n//           \"TransactionType\": \"Payment\",\n//           \"TxnSignature\": \"304402207D4F0636474CB5AB61362FAA03AE609F45772FE472E38ACB589DC63BEA779C1C02207058EF9E47C46E51E96703EBAE61E91BB32BC5CD48FF77CAF6CB7980B44295D2\",\n//           \"hash\": \"3F72E3C4C391AD1CE4E436CE68C3D6E16F8BA9FCDE911886D0AA6078BC8D1DF6\",\n//           \"metaData\": {\n//             \"AffectedNodes\": [\n//               {\n//                 \"ModifiedNode\": {\n//                   \"FinalFields\": {\n//                     \"Account\": \"rs1KQkwBYW1pY7jGeRiNgBkbD6WkPG4cYE\",\n//                     \"Balance\": \"2782924305\",\n//                     \"Flags\": 0,\n//                     \"OwnerCount\": 0,\n//                     \"Sequence\": 9114\n//                   },\n//                   \"LedgerEntryType\": \"AccountRoot\",\n//                   \"LedgerIndex\": \"A2A15502645DE43E85253F66C447D05B0A9C9927AA0C544AB0411A123D7FF80A\",\n//                   \"PreviousFields\": {\n//                     \"Balance\": \"2786924317\",\n//                     \"Sequence\": 9113\n//                   },\n//                   \"PreviousTxnID\": \"40AB3BD0DE0A8C952E29B5C45DDA0A18D4EDB27B579ABAF56257D7DC2E93D866\",\n//                   \"PreviousTxnLgrSeq\": 4718675\n//                 }\n//               },\n//               {\n//                 \"ModifiedNode\": {\n//                   \"FinalFields\": {\n//                     \"Account\": \"rpyUV8W6XRvss6SBkAS8PyzGwMsSDxgNXW\",\n//                     \"Balance\": \"1478454471599\",\n//                     \"Flags\": 0,\n//                     \"OwnerCount\": 0,\n//                     \"Sequence\": 228555\n//                   },\n//                   \"LedgerEntryType\": \"AccountRoot\",\n//                   \"LedgerIndex\": \"C754412E25ED3F4257524CED149B993DC1683BDEBE6E0514604008A9B259813B\",\n//                   \"PreviousFields\": {\n//                     \"Balance\": \"1478450471599\"\n//                   },\n//                   \"PreviousTxnID\": \"40AB3BD0DE0A8C952E29B5C45DDA0A18D4EDB27B579ABAF56257D7DC2E93D866\",\n//                   \"PreviousTxnLgrSeq\": 4718675\n//                 }\n//               }\n//             ],\n//             \"TransactionIndex\": 1,\n//             \"TransactionResult\": \"tesSUCCESS\"\n//           }\n//         },\n//         {\n//           \"Account\": \"ra7JkEzrgeKHdzKgo4EUUVBnxggY4z37kt\",\n//           \"Amount\": {\n//             \"currency\": \"USD\",\n//             \"issuer\": \"rMwjYedjc7qqtKYVLiAccJSmCwih4LnE2q\",\n//             \"value\": \"100\"\n//           },\n//           \"Destination\": \"rfUW4KCKvzdA4MCgoft1u5ojuQbpSFRktB\",\n//           \"Fee\": \"10\",\n//           \"Flags\": 0,\n//           \"SendMax\": {\n//             \"currency\": \"USD\",\n//             \"issuer\": \"rMwjYedjc7qqtKYVLiAccJSmCwih4LnE2q\",\n//             \"value\": \"100.00001\"\n//           },\n//           \"Sequence\": 123651,\n//           \"SigningPubKey\": \"02808D78A818D7B27FC43D27A5E793E354A72204E0ACD59A88BB13743FF0F14625\",\n//           \"SourceTag\": 926415956,\n//           \"TransactionType\": \"Payment\",\n//           \"TxnSignature\": \"3046022100EECB7E3083B924EF79F2366A50E8E5E22323E16515C502B47278AABB2E6E79260221008A1D05120284992C63FA75BFE1FB11F8823DD2238FE9DB6DF20185D133F8CA92\",\n//           \"hash\": \"80575096E403379AD2F37A4006FF59A69E9AFD0DF4CA70AC9C4CEE08B1AB5F09\",\n//           \"metaData\": {\n//             \"AffectedNodes\": [\n//               {\n//                 \"ModifiedNode\": {\n//                   \"FinalFields\": {\n//                     \"Account\": \"ra7JkEzrgeKHdzKgo4EUUVBnxggY4z37kt\",\n//                     \"Balance\": \"98863451\",\n//                     \"Flags\": 917504,\n//                     \"OwnerCount\": 1,\n//                     \"Sequence\": 123652\n//                   },\n//                   \"LedgerEntryType\": \"AccountRoot\",\n//                   \"LedgerIndex\": \"D72C5D772234B929C5025423FE111846E4F20EF92269368D4D264A12982FDFE4\",\n//                   \"PreviousFields\": {\n//                     \"Balance\": \"98863461\",\n//                     \"Sequence\": 123651\n//                   },\n//                   \"PreviousTxnID\": \"CC277E6C1063C20D1BA1C922C4081320CD316A330019DE7B479D569C9D5404A0\",\n//                   \"PreviousTxnLgrSeq\": 4718677\n//                 }\n//               }\n//             ],\n//             \"TransactionIndex\": 2,\n//             \"TransactionResult\": \"tecPATH_PARTIAL\"\n//           }\n//         }\n//       ]\n//     });",
          "reduce": "function(keys, values, rereduce) {\n  var sum = 0, count = 0;\n  values.forEach(function(val, index){\n    var to_add = parseFloat(val[0]);\n    if (typeof to_add === 'number') {\n      sum += to_add;\n    }\n    \n    if (rereduce) count += val[1];\n    else count++;\n  });\n  return [sum, count];\n}"
        }
      }
    },
    {
      "_id": "_design/valueSentV3",
      "language": "javascript",
      "validate_doc_update": "function(newDoc, oldDoc, userCtx, secObj) {\n    if (userCtx && userCtx.roles && (userCtx.roles.indexOf('_admin') !== -1 ||\n        userCtx.roles.indexOf('write') !== -1)) {\n        return;\n    } else {\n        throw ({\n            forbidden: 'You do not have write access to this database'\n        });\n    }\n}",
      "views": {
        "v3": {
          "map": "// function map (doc) {\nfunction(doc) {\n\n  var time = new Date(doc.close_time_timestamp);\n  var timestamp = [\n    time.getUTCFullYear(), \n    time.getUTCMonth(), \n    time.getUTCDate(),\n    time.getUTCHours(), \n    time.getUTCMinutes(), \n    time.getUTCSeconds()\n  ];\n\n  doc.transactions.forEach(function(tx){\n\n    if (tx.metaData.TransactionResult !== 'tesSUCCESS') {\n      return;\n    }\n\n    if (tx.TransactionType !== 'Payment' && tx.TransactionType !== 'OfferCreate') {\n      return;\n    }\n\n    var changes = parseBalanceChanges(tx);\n    \n    if (changes.length > 0) {\n      changes.forEach(function(change){\n        emit([change.currency, change.issuer].concat(timestamp), [0 - parseFloat(change.value), tx.Account, tx.Destination || null, tx.hash]);\n        //log(change);\n      });\n      \n      //log(tx.hash);\n    }\n    \n  });\n\n  function parseBalanceChanges (tx) {\n\n    var accountBalanceChanges = [];\n    var account     = tx.Account;\n    var destination = tx.Destination || null;\n    \n    tx.metaData.AffectedNodes.forEach(function(affNode){\n\n      var node = affNode.CreatedNode || affNode.ModifiedNode || affNode.DeletedNode;\n\n      // Look for XRP balance change in AccountRoot node\n      if (node.LedgerEntryType === 'AccountRoot') {\n\n        var xrpBalChange = parseAccountRootBalanceChange(node, account);\n        \n        if (xrpBalChange) {\n          xrpBalChange.value += parseFloat(tx.Fee); //remove the fee from the balance change\n          \n          //if we are still negative, XRP was sent.\n          //often this would be zero, indicating only a fee\n          //and not really sending XRP\n          if (xrpBalChange.value<0) {\n            xrpBalChange.value = dropsToXrp(xrpBalChange.value); //convert to XRP\n            accountBalanceChanges.push(xrpBalChange);\n          }\n        }\n      }\n\n      // Look for trustline balance change in RippleState node\n      if (node.LedgerEntryType === 'RippleState') {\n\n        var currBalChange = parseTrustlineBalanceChange(node, account, destination);\n        if (currBalChange) {\n          accountBalanceChanges.push(currBalChange);\n        }\n\n      }\n\n    });\n\n    return accountBalanceChanges;\n  }\n\n\n  function parseAccountRootBalanceChange (node, account) {\n\n/*\n    if (node.NewFields) {\n\n      if (node.NewFields.Account === account) {\n        return {\n          value: dropsToXrp(node.NewFields.Balance),\n          currency: 'XRP',\n          issuer: ''\n        };\n      }\n\n    } else if (node.FinalFields) {\n*/\n      \n    if (node.FinalFields && node.FinalFields.Account === account) {\n\n      var finalBal = node.FinalFields.Balance,\n        prevBal    = node.PreviousFields.Balance,\n        balChange  = finalBal - prevBal;\n      \n      //if the final balance is greater than the previous, xrp was sent\n      if (balChange<0) return {\n        value    : balChange,\n        currency : 'XRP',\n        issuer   : ''\n      };\n    }\n\n\n    return null;\n  }\n\n  function parseTrustlineBalanceChange (node, account, destination) {\n\n    var balChange = {\n        value    : 0,\n        currency : '',\n        issuer   : ''\n      }, \n      trustHigh,\n      trustLow,\n      trustBalFinal,\n      trustBalPrev;\n\n    if (node.NewFields) {\n      trustHigh     = node.NewFields.HighLimit;\n      trustLow      = node.NewFields.LowLimit;\n      trustBalFinal = parseFloat(node.NewFields.Balance.value);\n    } else {\n      trustHigh     = node.FinalFields.HighLimit;\n      trustLow      = node.FinalFields.LowLimit;\n      trustBalFinal = parseFloat(node.FinalFields.Balance.value); \n    }\n\n    if (node.PreviousFields && node.PreviousFields.Balance) {\n      trustBalPrev = parseFloat(node.PreviousFields.Balance.value);\n    } else {\n      trustBalPrev = 0;\n    }\n\n    //ignore any balance changes that do not affect the sending account\n    if (account != trustHigh.issuer && account != trustLow.issuer) {\n      return null;  \n    }\n    \n    // Set currency\n    balChange.currency = (node.NewFields || node.FinalFields).Balance.currency;\n\n    // Set issuer\n    // rules:  \n    //    if the balance is negative, the low party is the issuer\n    //    if the balance is 0, and the balance was previously negative, the low party is the issuer\n    //    if the balance is 0, and the balance was previously positive, the high party is the issuer\n    //    if the balance is positive, the high party is the issuer\n    if (trustBalFinal < 0)                         balChange.issuer = trustLow.issuer;\n    else if (trustBalFinal==0 && trustBalPrev < 0) balChange.issuer = trustLow.issuer; \n    else                                           balChange.issuer = trustHigh.issuer;\n    \n    balChange.value = parseFloat(trustBalFinal) - parseFloat(trustBalPrev);  \n\n    //if the issuer is sending, invert it because its always positive\n    if (balChange.issuer==account) \n      balChange.value = 0 - balChange.value; \n    \n    //if its being sent to the issuer and the issuer\n    //is the low party, invert it \n    if (balChange.issuer==destination && trustLow.issuer==balChange.issuer)\n      balChange.value = 0 - balChange.value;\n\n    //because we are including \"OfferCreate\", the account's balance\n    //could have increased.  therefore, we only want to include \n    //negative balance changes - i.e. balances where money left the\n    //sender/initiator's account\n    if (balChange.value > 0) return null;\n    \n    return balChange;\n  }\n\n  function dropsToXrp (drops) {\n    return parseFloat(drops) / 1000000.0;\n  }\n\n  function xrpToDrops (xrp) {\n    return parseFloat(xrp) * 1000000.0;\n  }\n\n}",
          "reduce": "function(keys, values, rereduce) {\n  var sum   = 0\n  var count = 0;\n  var i;\n  \n  for (i=0; i<values.length; i++) {\n    sum += value[0];\n    \n    if (rereduce) count += val[1];\n    else count++;\n  }\n  \n  return [sum, count];\n}"
        }
      }
    }
  ]
}